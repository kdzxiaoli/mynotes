数组 链表  红黑树

为什么要用数组   速度快   
数组  速度最快  O（1） 知道索引  
涉及删除 插入  复杂度 O(n)  

计算下标

hashcode() & (length() -1)


链表     插入  复杂度 O(1)
查找O(n)


如果频繁put 导致要平衡  所以性能比链表要低


初始化容量  不一定就是你定的大小  而是找一个比你设定值大的第一个2的幂等值
hash()   hashcode ^ hashcode >>> 16  扰动因子  混合高低位  加大低位的随机性

为什么是2的指数幂

因为 计算数组的下标为hash & (length -1 )  防止数组越界

线程不安全

jdk1.7 头插法  链表形成一个环 陷入死锁 
jdk1.8 尾插法

为什么速度快 

不需要重新hash
红黑树

0.75  
在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循泊松分布，同时给出了桶中元素个数和概率的对照表。从上面的表中可以看到当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个的概率达到了一百万分之一
红黑树  8

为了配合使用分布良好的hashCode，树节点很少使用。并且在理想状态下，受随机分布的hashCode影响，链表中的节点遵循泊松分布，而且根据统计，链表中节点数是8的概率已经接近千分之一，而且此时链表的性能已经很差了。所以在这种比较罕见和极端的情况下，才会把链表转变为红黑树。因为链表转换为红黑树也是需要消耗性能的，特殊情况特殊处理，为了挽回性能，权衡之下，才使用红黑树，提高性能。也就是大部分情况下，hashmap还是使用的链表，如果是理想的均匀分布，节点数不到8，hashmap就自动扩容了




扩容 n*2



