简述
Java中每个对象都可以用来实现一个同步的锁，这些锁被称为内置锁（Intrinsic Lock）或监视器锁（Monitor Lock）。

具体表现形式如下：

1、普通同步方法，锁的是当前实例对象

2、静态同步方法，锁的是当前Class对象

3、对于同步代码块，锁的是Synchronized括号中的代码块

线程在进入同步代码块之前会自动获取锁，并且在退出同步代码块时自动释放锁，无论是通过正常路径退出，还是通过代码块中抛出异常退出。获得内置锁的唯一途径就是进入由这个锁保护的同步方法或代码块。

从 JVM 规范 中 可以 看到 Synchonized 在 JVM 里 的 实现 原理， JVM 基于 进入 和 退出 Monitor 对象 来 实现 方法 同步 和 代码 块 同步， 但 两者 的 实现 细节 不一样。 代码 块 同步 是 使用 monitorenter 和 monitorexit 指令 实现 的， 而 方法 同步 是 使用 另外 一种 方式 实现 的， 细节 在 JVM 规范 里 并没有 详细 说明。 但是， 方法 的 同步 同样 可以 使用 这 两个 指令 来 实现。

monitorenter 指令 是在 编译 后 插入 到 同步 代码 块 的 开始 位置， 而 monitorexit 是 插入 到 方法 结束 处 和 异常 处， JVM 要 保证 每个 monitorenter 必须 有 对应 的 monitorexit 与之 配对。 任何 对象 都有 一个 monitor 与之 关联， 当 且 一个 monitor 被 持有 后， 它将 处于 锁定 状态。 线程 执行 到 monitorenter 指令时， 将会 尝试 获取 对象 所 对应 的 monitor 的 所有权， 即 尝试 获得 对象 的 锁。

 

对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。

synchronized 用的锁 是 存在 对象头 中。 
如果 对象是数组类型， 则虚拟机用 3 个字 宽（ Word） 存储 对 象头， 如果对象是非数组类型， 则用 2字宽存储 对 象头。 在 32位虚拟 机中， 1 字 宽 等于 4 字节， 即 32bit。


HotSpot虚拟机的对象头包括两部分信息：
Mark Word   第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit。
类型指针       对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，这点将在2.3.3节讨论。
实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。
对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用
